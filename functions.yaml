functions:

########################################################## facades required

  context_content_refined:
    title: Содержимое c учетом точки зрения
    params:
      - type: string
        title: Доменный идентификатор
        alias: domain
        required: true
      - type: object
        title: Глобальный контекст ($$)
        alias: ctxG
        required: true

    code: >
      (
            $domain:= domain;
            $ctxG:= ctxG;
            $byCtx:= $byContext($ctxG); 
            
            $isContext:= $byCtx[$.context = $domain]
              ? true
              : false;


            $wrapping_context:= $isContext
                                  ? $byCtx[$domain in $.content.object_id and 
                                                $domain != $.context].context
                                  : $byCtx[$domain in $.content.object_id].context;
            $members:= $isContext
              ? (
                  $members:=  $map($byCtx[$.context = $domain].content, function($v) {
                                $v.object_id in $byCtx.context
                                  ? {"membersCtx": {"id": $v.object_id, "body": $v.body ~> |$|{"entity_id": $v.entity_id, "entity_title": $v.entity_title}|}}
                                  : {"membersOrd": {"id": $v.object_id, "body": $v.body ~> |$|{"entity_id": $v.entity_id, "entity_title": $v.entity_title}|}}
                              });
                  
                  $facades:= $getFacadesImpressed($domain, $byCtx, $ctxG);

                  $facades:= $map($facades, function($v) {
                    {"membersOrd": $v~>|$|{"id": $.object_id, "body": $merge([$.body, {"overriden": $.overriden, "entity_id": $.entity_id, "entity_title": $.entity_title}])}, ["object_id", "overriden", "entity_id", "entity_title"]|}
                  });
                  
                  $members:= $count($facades) > 0
                   ? (/*$facades_enriched:= $map($facades, function($v) {(
                        $members.membersCtx[$.id = $v.object_id]
                          ? {"membersCtx":{"id": $v.object_id, "body": $merge([$.body, $v.body])}}
                          : $members.membersOrd[$.id = $v.object_id]
                              ? {"membersOrd":{"id": $v.object_id, "body": $merge([$.body, $v.body])}}
                              : {"membersOrd": {"id": $v.object_id, "body": $v.body~>|$|{"entity_id": $v.entity_id}|}}
                      )});*/
                      $append($map($members, function($v) {(
                        $not($v.*.id in $facades.membersOrd.id)
                          ? $v
                      )}), $facades);
                      )
                   : $members;
                );
              
            $neighbours:= $map($byCtx[$.context = $wrapping_context].content, function($v) {
                             $v.object_id in $byCtx.context
                                ? {"neighboursCtx": {"id": $v.object_id, "body": $v.body ~> |$|{"entity_id": $v.entity_id}|}}
                                : {"neighboursOrd": {"id": $v.object_id, "body": $v.body ~> |$|{"entity_id": $v.entity_id}|}}
                        });
            
            $facades:= $wrapping_context ? $getFacadesImpressed($wrapping_context, $byCtx, $ctxG);

              $neighbours:= $count($facades) > 0
                   ? ($facades_enriched:= $map($facades, function($v) {(
                        $neighbours.neighboursCtx[$.id = $v.object_id]
                          ? {"neighboursCtx":{"id": $v.object_id, "body": $merge([$.body, $v.body])}}
                          : $neighbours.neighboursOrd[$.id = $v.object_id]
                              ? {"neighboursOrd":{"id": $v.object_id, "body": $merge([$.body, $v.body])}}
                              : {"neighboursOrd": {"id": $v.object_id, "body": $v.body~>|$|{"entity_id": $v.entity_id}|}}
                      )});
                      $append($map($neighbours, function($v) {
                        $not($v.*.id in $facades_enriched.*.id)
                          ? $v
                      }), $facades_enriched);
                      )
                : $neighbours;
            
            {"isContext": $isContext, 
             /*"wrapper": $distinct($byCtx.content[$.object_id = $wrapping_context].{"id": $wrapping_context, "body": $.body}),*/
             "wrapper": $wrapping_context,
             "observable": $append($members, $neighbours)
            }
      )
    result:
      type: object

  getFacadesImpressed:
    title: Найти фасады, выставленные в данный контекст
    params:
      - type: string
        alias: ctx
        required: true
      - type: array
        title: Контексты ограниченные сверху и снизу
        alias: byContext
        required: true
      - type: object
        title: Глобальный контекст ($$)
        alias: ctxG
        required: true
    code: >
      (
        $ctx:= ctx; $byCtx:= byContext; $ctxG:= ctxG;

        $ctx_list:= $dh_essentials_contexts($ctxG).context; 
        $expositions:=  $map($byCtx.content, function($v){(
                          $map($v.body.exposed.$keys($), function($vk) {(
                            $ex:= $map($seaf_ddd_tree($vk).paths, function($vv, $ii, $aa) {(
                                    $path:= $aa[-2 - $ii];
                                    $path in $ctx_list and
                                    $contains($path, $ctx) and
                                    $substringBefore($path, $ctx) = ""
                                      ? [$path]
                                  )});
                            $reduce($ex, $append)[0] = $ctx 
                              ? ( $resident:= $byCtx[$.context = $ctx].content[$.object_id = $vk];

                              $v~>|$.body|$resident? $merge([$eval("$.body.exposed." & "'" & $vk & "'"), {"resident": $resident.body}]) :$eval("$.body.exposed." & "'" & $vk & "'")|)
                          )})
                        )});
        
        $expositions:= $distinct($reduce($expositions, $append));

        $impressed:=[$map($expositions, function($v) {(
                      $k:= $v.body.exposed.$keys()[$contains($, $ctx)];
                      {"object_id": $k, "body": $merge([$merge([$eval("$v.body.exposed." & "'" & $k & "'"), $v.body.resident]), {"impressed": $v.object_id}]), "overriden": $v.body.resident? true : false, "entity_id": $v.entity_id, "entity_title": $v.entity_title}
                    )})];

      )



#################################################### Contexts menu required

  byContext:
    title: Raw distribution of objects by contexts (with no facades impressed)
    params:
      - type: object
        title: $$
        alias: ctxG
        required: true
    code: >
      (   
          $ctxG:= ctxG;
          $contexts_id:= $dh_essentials_contexts($ctxG).context;
          
          $contexts_till_down:= $map($contexts_id, function($v) {
              {
                "context": $v,
                "content": $seaf_context_content($v, $ctxG)
                }
          });

          /*sort contexts from lowest (no other contexts inside)             */
          /*                to highest (includes max number of other contexts*/
          $contexts_id:= $contexts_till_down.context;
          $contexts_id_ordered:=
          $map($contexts_id, function($v) {(
            {$v: $count($map($contexts_id[$ != $v], function($vv) {
                          $vv in $contexts_till_down[$.context = $v].content.object_id
                            ? {$v: $vv}
                            : {$v: null}
                        })[$.* != null]
                  )
            }
          )})^(<$.*).$keys();
            
          $trim:= function($order, $i, $contexts){(
            $toTrimOff:= $contexts[$.context = $order[$i]];
            $toTrim:= $contexts[$.context !=  $order[$i]];
            $contexts:= $map($toTrim, function($v){
                          $v~>|$|{"content": $map($v.content, function($vv){(
                                                $not($vv.object_id in $toTrimOff.content.object_id) or
                                                $vv.object_id = $toTrimOff.context or
                                                $vv.object_id = $v.context
                                                  ? $vv
                                              )})
                                  }|
                        });
            $contexts:= $append($contexts, $toTrimOff);
            $i < $count($order)-1
              ? $trim($order, $i+1, $contexts)
              : $contexts
          )};
          $contexts_isolated:= $trim($contexts_id_ordered, 0, $contexts_till_down);

          $ctxG:= {
            "context": "ctxG",
            "content": 
            /*
              $append(
                [{"object_id": "ctxG", "body": {"title": "глобальный"}}],
            */
                [$distinct($contexts_isolated.content[$.object_id in $seaf_ddd_top($ctxG."seaf.ba.parties")])]
             /* )*/
            };
          $append($ctxG, $contexts_isolated)
      )


  seaf_context_content:
    title: Содержимое контекста
    params:
      - type: string
        title: Идентификатор объекта
        alias: obj_id
        required: true
      - type: object
        title: Глобальный Контекст -- $$
        alias: ctx
        required: true
    code: >
      (
          $obj_id:= obj_id;
          $ctx:= ctx;

          $arch_entities_id:= [$dh_lake_map($ctx).entities.list.arch_entities];
          $context_content:=  $map($arch_entities_id, function($v) {
                                        $map($eval("$ctx" & "." & "\"" & $string($v.entity) & "\"").$keys()[$contains($, $obj_id) and 
                                                                                            $substringBefore($, $obj_id) = "" 
                                                                                            ], function($vv) {
                                            
                                            {
                                                "object_id": $vv,
                                                "body": $ctx.$lookup($eval("$ctx" & "." & "\"" & $v.entity & "\""), $vv),
                                                "entity_id": $v.entity,
                                                "entity_title": $v.title
                                            }
                                        })
                                });
          $context_content:= [$reduce($context_content, $append)];
      )
    result:
      type: array
      description: >
        Перечень объектов контекста {"obj", "entity"}

  dh_essentials_contexts:
    title: Возвращает перечень контекстов (auto + manual) и пути в меню
    params:
      - type: object
        title: Область поиска контекстов (глобальный Контекст -- $$)
        alias: ctx
        required: true
    code: >
      (   
          $ctx:= ctx;

          /*$parties:= $ctx."seaf.ba.parties";
          $top_domains:= $parties
            ? $seaf_ddd_top($ctx."seaf.ba.parties");   */                     /*auto top domains discovery goes among parties (main arch entity)*/
          $user_defined:= $count($dh_lake_map($ctx).ddd_contexts.list) > 0                          /*non-top parties and other entities are considered as context if they listed in seaf.self*/
            ? $dh_lake_map($ctx).ddd_contexts.list[$ in $ctx.*.$keys()];                        
          $contexts_id:= $distinct($append($top_domains, $user_defined ));

          $contexts:= $map($contexts_id, function($v){(
                        $full_paths:= $seaf_ddd_tree($v).paths;

                        $menu_path:= function($arr, $i, $path){(
                                  $arch_entities:= [$dh_lake_map($ctx).entities.list.arch_entities];
                                  $arch_entities_id:= [$arch_entities.entity];
                                  $obj:= $dh_ctx_objects($arch_entities_id, $ctx);
                                  $obj:= $obj.$spread().
                                    [$@$entity.*.
                                      [$.$spread().
                                        {"object_id": $.$keys(),
                                        "object_title": $.*.title,
                                        "entity_id": $entity.$keys(),
                                        "entity_title": $arch_entities[$.entity = $entity.$keys()].title
                                        }
                                      ]
                                    ];
                                    $obj:= $reduce($obj, $append)[$.object_id=$arr[$i]];
                          
                          $obj:= $count($obj)>1 ? $obj[$not($.entity_id = "components")] : $obj;                          
                          $not($i > 0)
                            ? $path:= $obj.object_title
                            : $path:= $path & "/" & $obj.object_title;
                          $i < $count($arr)-1
                            ? $menu_path($arr, $i+1, $path)
                            : {"context": $v, "menu_path": $path, "entity_id": $obj.entity_id, "entity_title": $obj.entity_title}
                        )}; $menu_path([$full_paths], 0, "");

                      )});
            [$contexts];
      )
    result:
      type: array
      description: массив объектов {location, link(presentation)}

  seaf_ddd_tree:
    title: Получение дерева DDD из идентификатора объекта
    params:
      - type: string
        title: Идентификатор объекта
        alias: obj_id
        required: true
    code: >
      (
          $obj_id:= obj_id;

          $getDDDWrappers:= function($obj_id){(
            $domains:= $split($obj_id, ".");
            $domains:= $count($domains) > 0
              ? $domains
              : [];
            $getPaths:= function($domains, $i, $paths){(
              $paths:= $i=0
                        ? $domains[0]
                        : $append($paths, $paths[$i-1] & "." & $domains[$i]);
              $i < $count($domains)-1 
                ? $getPaths($domains, $i+1, $paths)
                : $paths 
            )};
            $paths:= $getPaths($domains, 0, []);
            
            { 
              "domains": [$domains],  /*includes $obj_id tail*/
              "paths": [$paths]       /*includes $obj_id itself*/
            }
          )};

          $getDDDWrappers($obj_id);
      )
    result:
      type: object
      description: >
        domains -- массив идентификаторов доменов (d1, d2, ...), 
        paths -- массив "путей" (d1, d1.d2, ...)

  seaf_ddd_top:
    title: Получение DDD верхнего уровня
    params:
      - type: object
        title: Объекты сущности
        alias: objects
    code: >
      (
        $ctxG:= ctxG;
        $objects:= objects.$spread();
        $tops:= $map($objects, function($v) {(
                  $paths:= $seaf_ddd_tree($v.$keys()).paths;

                  $getTop:= function($paths, $i){(
                    $paths[$i] in $objects.$keys()
                      ? $paths[$i]
                      : $getTop($paths, $i+1)
                  )};

                  $top:= $getTop($paths, 0);
                )});

        [$distinct($tops)]        
      )
    result:
      type: array
      description: Верхние DDD домены




####################################################### required before contexts

  dh_ctx_objects:
    title: DH context's objects
    description: Gets objects by entities list from given context
    params:
      - type: array
        title: Entities list
        alias: entities_list
        required: true
      - type: object
        title: Context
        alias: ctx
        required: true
    code: >
      (
        $entities_list:= entities_list; $ctx:= ctx;

        $merge($map($entities_list, function($v){(
            $objects:= $eval("$ctx." & "\"" & $v & "\"");
            $count($objects.$keys()) > 0
                ? {$v: $objects}
        )}))
        
      )

  dh_lake_map:
    title: DH Lake Map
    description: Gets top lake branches structure
    params:
      - type: object
        title: Lake
        alias: lake
        required: true
    code: >
      (
        $ctxG:= lake;
        $config:= $ctxG."dochub.essentials.config";

        $merge(
          $map($distinct($config.key), function($v, $i, $a){(
              $key_configs:= $config[$.key = $v];
              $key_configs:= {$distinct($key_configs.key): $key_configs~>|$|{},["key"]|};
              
              $v = "$package"
                  ? $key_configs~>|$eval("$." & "\"" & $v & "\"")|{"list": $spread($ctxG."$package")}|
              
            : $v = "imports"    
                  ? ($count($key_configs.imports) > 1
                      ? {$key_configs.$keys(): $merge($key_configs.imports)}
                      : $key_configs)

            : $v = "rules"
                  ? ( $rules_list:= $ctxG.rules.validators.$spread($);
                      $count($rules_list) > 0
                            ? $key_configs~>|$eval("$." & $v)|{"list": $rules_list.{"rule": $keys($), "title": $.*.title, "description": $.*.description}}|
                            : $key_configs)

            : $v = "functions"
                  ? ( $func_list:= $ctxG.functions.$spread($);
                      $count($func_list) > 0
                            ? $key_configs~>|$eval("$." & $v)|{"list": $func_list.{"function": $keys($), "title": $.*.title, "description": $.*.description}}|
                            : $key_configs)

            : $v = "docs"
                  ? ( $docs_list:= $ctxG.docs.$spread($);
                      $count($docs_list) > 0
                            ? $key_configs~>|$eval("$." & $v)|{"list": $docs_list.{"doc": $keys($), "title": $.*.title, "description": $.*.description, "source": $.*.template ? $.*.template : $not($.*.type = "mkr-grid" or $.*.type = "smartants") ? $.*.source}}|
                            : $key_configs)

            : $v = "icons"
                  ? ($count($key_configs.icons) > 1
                            ? {$key_configs.$keys(): $merge(($key_configs~>|$.icons|{"list":$key_configs.icons.list}|).icons)}
                            : $key_configs)

            : $v = "ddd_contexts"
                  ? ($count($key_configs.ddd_contexts) > 1
                            ? {$key_configs.$keys(): $merge(($key_configs~>|$.ddd_contexts|{"list":$key_configs.ddd_contexts.list}|).*)}
                            : $key_configs)            

            : $v = "entities"
                  ? ( $entities_list:= $ctxG.entities.$spread();
                      $arch_entities_list:= $entities_list[$.*.objects and $not($.*.not_arch_entity = true)];
                      $not_arch_entities_list:= $entities_list[$not($exists($.*.objects)) or $.*.not_arch_entity = true];
                      $undefined_entities_list:= $ctxG.$keys()[$not($ in $entities_list.$keys()) and $not($ in $a)];
                      $count($entities_list) > 0
                            ? $key_configs~>|$eval("$." & $v)|{"list": { "arch_entities": $arch_entities_list.{"entity": $keys($), "title": $.*.title, "description": $.*.description},
                                                                        "not_arch_entities": $not_arch_entities_list.{"entity": $keys($), "title": $.*.title, "description": $.*.description},
                                                                        "undefined_entities": $undefined_entities_list.{"entity": $}}}|
                            : $key_configs)

            : {"undefined_configured_entity": $merge([{"entity": $key_configs.$keys()}, $key_configs.*])}
        )}))     
      )
    result:
      type: object
      description: List of Packages, Manifests, Rules, functions, Docs, Arch and non-Arch Entities, Undefined entities

  getSymbol_t1:
    title: Сформировать svg-символы для SmartAnts
    params:
      - type: string
        title: Main title
        alias: title
        required: true
      - type: string
        title: Entity id
        alias: entity_id
        required: true
      - type: number
        title: Symbol width in pixels
        alias: symbol_width
        required: true
      - type: object
        title: Шаблоны иконок
        alias: icons
        required: true
    code: >
      (
        $title:= title; $entity_id:= entity_id; $symbol_width:= symbol_width; $icons:= icons;
        
        $symbol_title:= $split($entity_id, ".")[-1];
        $symbol_obj:= $eval("$icons." & $symbol_title);
        $symbol_gliph:= $symbol_obj.gliph;
        $symbol_template:= $symbol_gliph ?
          $match($symbol_gliph, /^(<svg)[^>]+>/, 1).match &
          '<rect x="0" y="-960" width={{vbWidth}} height="960" rx="300" fill="' & $symbol_obj.back_color & '"/>' &
          '<text style="font-size:800px;" x="1200" y="-250" fill="' & $symbol_obj.fore_color & '" font-family="monospace">{{title}}</text>' &
          $match($symbol_gliph, /(<path)[^>]+>/, 1).match &
          '</svg>'
        ;
        $symbol_template:= $symbol_template
            ? $symbol_template
            : $icons.no_icon;
        $symbol_svg:= $replace($symbol_template, /\{\{title\}\}/, $title); 
        $symbol_svg:= $replace($symbol_svg, /\{\{fore_color\}\}/, $symbol_obj.fore_color);
        $symbol_svg:= $replace($symbol_svg, /\{\{back_color\}\}/, $symbol_obj.back_color);
        $symbol_svg:= $replace($symbol_svg, /\{\{absWidth\}\}/, $string($symbol_width)); 
        $symbol_svg:= $replace($symbol_svg, /\{\{vbWidth\}\}/, $string(4000*$symbol_width/100)); 

        {"title": $symbol_title & "_" & $title, "svg": $symbol_svg}
      )
    result:
      type: object

  getIcons:
    title: Получить набор иконок
    params:
      - type: array
        title: Icon Sets List
        alias: icon_sets_list
        required: true
      - type: object
        title: Context
        alias: ctx
        required: true
    code: >
      (
        $icon_sets_list:= icon_sets_list; $ctx:= ctx;
        
        $icons:= function($sets, $icons_obj, $i) {(
          $set:= $eval("$ctx." & "\"" & $sets[$i] & "\"");
          $icons_obj:= $merge([$icons_obj, $set]);
          $i<$count($sets)-1
            ? $icons($sets, $icons_obj, $i+1)
            : $icons_obj
        )};

        $icons_list:= $count($icon_sets_list) > 0
          ? $icons($icon_sets_list, {}, 0)
          : {}
      )
    result:
      type: object

  _essentials:
    title: DH Essentials imported
    params:
      - type: number
        title: Dummy param
        alias: dummy
        required: false
    code: dummy
    result: {type: number}

